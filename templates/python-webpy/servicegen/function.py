# CAREFUL:
# This code was generated by the `servicegen' framework.
# Do not edit this file directly.

import web
from setup import logger

class TerminateRequest(Exception):
    """Exception thrown when the request should be terminated."""
    pass

def validate(value, comparison):
    matches = True
    try:
        matches = (comparison.match(value) != None)
    except AttributeError:
        matches = (str(value) == str(comparison))
    if not matches:
        web.ctx.status = '400 Bad Request'
        web.ctx.outputter.write_exception(('invalid value', 'Invalid value "' + value + '"'))
        raise TerminateRequest, 'Invalid value "' + value + '"'

def etag(etag):
    """
    Calling the etag function allows you to implement a very easy HTTP cache
    handling. You call it with the hash you want to assign to the current request.
    If you pass in any non-string data type, servicegen will calculate a hash out
    of the variable's content.

    If the client has sent a "If-None-Match" HTTP header containing exactly
    that hash, then the request is immediately aborted and the response code
    304 (Not Modified) or 412 (Precondition Failed) is sent. If the client
    sets the "no-cache" option in its "Cache-Control" header, this behaviour
    is turned off.
    
    In the case that the request continues, the "ETag" response header is set.
    """
    web.header('ETag', etag)
    
    if 'HTTP_IF_NONE_MATCH' in web.ctx.env:
        request_tag = web.ctx.env['HTTP_IF_NONE_MATCH']
        tags = request_tag.split(',')
        for tag in tags:
            if tag.strip() == etag or tag.strip() == '*':
                # Matches
                if web.ctx.method.lower() in ('get', 'head'):
                    web.ctx.status = '304 Not Modified'
                else:
                    web.ctx.status = '412 Precondition Failed'
                raise TerminateRequest, 'Cached response for ETag "' + etag + '"'

def expires(delta):
    """
    Specifies how long the response is to be cached by clients. The input must be
    of the duration variable type. For any other value the function will return
    and log an error.

    The function sets the two HTTP headers "Expires" and "Cache-Control"
    correctly. Expires is for HTTP/1.0 implementations, Cache-Control for 1.1. The
    effect is that the client knows that it can (but doesn't have to) cache the
    response for the duration period.
    
    Duration must be a datetime.timedelta object (a duration in servicegen)
    """
    delta_secs = delta.days * 86400 + delta.seconds
    web.expires(delta)
    web.header('Cache-Control', 'max-age=' + str(delta_secs))

def get_cache(key):
    return None

def set_cache(key, value):
    return True

log = logger
